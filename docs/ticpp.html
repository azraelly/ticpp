<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TinyXml: TinyXML++</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.3 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="annotated.html"><span>Classes</span></a></li>
    <li><a href="files.html"><span>Files</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul>
</div>
<div class="nav">
<a class="el" href="index.html">index</a>&nbsp;&raquo&nbsp;<a class="el" href="ticppTutorial.html">TinyXML++ Tutorial</a></div>
<h1><a class="anchor" name="ticpp">TinyXML++</a></h1><h2>General Concepts </h2>
<p>
The TinyXML++ classes are all wrappers around the corresponding classes within TinyXML.<p>
There is no reason to create TinyXML++ objects on the heap, using <code>new</code>, because the memory is managed for you. If you choose to use <code>new</code> to create TinyXML++ objects, you will <b>always</b> need to use <code>delete</code> to clean up.<p>
Basically, TinyXML++ objects are just wrappers around TinyXML pointers.<p>
<h2>Goals </h2>
<p>
<ul>
<li>Simplify the use and interface of TinyXml, using C++ concepts.<ul>
<li>Use exceptions for error handling, so there are no return codes to check</li><li>Use templates for automatic type conversion</li><li>Use STL style iterators to move through nodes and attributes</li></ul>
</li></ul>
<p>
<h2>Details </h2>
<p>
<h3>Use exceptions for error handling </h3>
<p>
When using the original TinyXML, every function returns a value indicating success or failure. A programmer would have to check that value to ensure the function succeeded.<p>
Example: <div class="fragment"><pre class="fragment"><span class="comment">// Load a document</span>
<a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> doc( pFilename );
<span class="keywordflow">if</span> ( !doc.LoadFile() ) <span class="keywordflow">return</span>;

<span class="comment">// Get a node</span>
<a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* pElem = doc.FirstChildElement();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

<span class="comment">// Get the node we want</span>
pElem = pElem-&gt;<a class="code" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9" title="STL std::string form.">NextSibling</a>();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

<span class="comment">// do something useful here</span>
</pre></div><p>
An alternative was to use <a class="el" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a>, which allows for function chaining by checking the intermediate function return values:<p>
Example: <div class="fragment"><pre class="fragment"><span class="comment">// Load a document</span>
<a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> doc(pFilename);
<span class="keywordflow">if</span> (!doc.LoadFile()) <span class="keywordflow">return</span>;

<span class="comment">// Make a document handle</span>
<a class="code" href="classTiXmlHandle.html" title="A TiXmlHandle is a class that wraps a node pointer with null checks; this is an incredibly...">TiXmlHandle</a> hDoc(&amp;doc);

<span class="comment">// Get an element by using the handle to chain calls</span>
<span class="comment">// Note the conversion of the TiXmlHandle to the TiXmlElement* - .Element()</span>
<a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* pElem = hDoc.<a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>().<a class="code" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9" title="STL std::string form.">NextSibling</a>().Element();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

<span class="comment">// do something useful here</span>
</pre></div><p>
With TinyXML++, if there is an error during a function call, it throws an exception. This means that a programmer can assume that every function is successful, as long as the functions are enclosed in a try-catch block.<p>
Example: <div class="fragment"><pre class="fragment"><span class="keywordflow">try</span>
{
    <span class="comment">// Load a document</span>
    <a class="code" href="classticpp_1_1Document.html" title="Wrapper around TiXmlDocument.">ticpp::Document</a> doc( pFilename );
    doc.LoadFile();

    <span class="comment">// Get an element by chaining calls - no return values to check, no TiXmlHandle</span>
    <a class="code" href="classticpp_1_1Element.html" title="Wrapper around TiXmlElement.">ticpp::Element</a>* pElem = doc.<a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>()-&gt;<a class="code" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9" title="STL std::string form.">NextSibling</a>();

    <span class="comment">// do something useful here</span>
}
<span class="keywordflow">catch</span>( <a class="code" href="classticpp_1_1Exception.html" title="This is a ticpp exception class.">ticpp::Exception</a>&amp; ex )
{
    <span class="comment">// If any function has an error, execution will enter here.</span>
    <span class="comment">// Report the error</span>
    std::cout &lt;&lt; ex.<a class="code" href="classticpp_1_1Exception.html#eac1f13b96eb4e1f2a3659dc9080edd6" title="Override std::exception::what() to return m_details.">what</a>();
}
</pre></div><p>
<h3>Use templates for automatic type conversion </h3>
<p>
When using TinyXML, a programmer either needs to convert values to and from strings, or choose from one of many overloads to get the value in the desired type.<p>
Example: <div class="fragment"><pre class="fragment"><span class="comment">// Load a document</span>
<a class="code" href="classTiXmlDocument.html" title="Always the top level node.">TiXmlDocument</a> doc( pFilename );
<span class="keywordflow">if</span> ( !doc.LoadFile() ) <span class="keywordflow">return</span>;

<span class="comment">// Get a node</span>
<a class="code" href="classTiXmlElement.html" title="The element is a container class.">TiXmlElement</a>* pElem = doc.<a class="code" href="classticpp_1_1Node.html#78fede114cf3c4608162891411db0c56" title="The first child element of this node.">FirstChildElement</a>();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

<span class="comment">// Get the node we want</span>
pElem = pElem-&gt;<a class="code" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9" title="STL std::string form.">NextSibling</a>();
<span class="keywordflow">if</span> ( !pElem ) <span class="keywordflow">return</span>;

<span class="comment">// Get the attribute as a string, convert to int</span>
<span class="keyword">const</span> <span class="keywordtype">char</span>* pszAttr = pElem-&gt;<a class="code" href="classTiXmlElement.html#e419a442a9701a62b0c3d8fd1cbdd12d" title="Given an attribute name, Attribute() returns the value for the attribute of that...">Attribute</a>( <span class="stringliteral">"myAttribute"</span> );
<span class="keywordtype">int</span> attr = atoi( pszAttr );

<span class="comment">// Get the attribute as an int</span>
<span class="keywordtype">int</span> attr2;
<span class="keywordflow">if</span> ( TIXML_SUCCESS != pElem-&gt;<a class="code" href="classTiXmlElement.html#ea0bfe471380f281c5945770ddbf52b9" title="QueryIntAttribute examines the attribute - it is an alternative to the Attribute()...">QueryIntAttribute</a>( <span class="stringliteral">"myAttribute"</span>, &amp;attr2 ) )
{
    <span class="keywordflow">return</span>;
}

<span class="comment">// Get the attribute as a double</span>
<span class="keywordtype">double</span> attr3;
<span class="keywordflow">if</span> ( TIXML_SUCCESS != pElem-&gt;<a class="code" href="classTiXmlElement.html#898d7730ecc341f0bffc7a9dadbf1ce7" title="QueryDoubleAttribute examines the attribute - see QueryIntAttribute().">QueryDoubleAttribute</a>( <span class="stringliteral">"myAttribute"</span>, &amp;attr3 ) )
{
    <span class="keywordflow">return</span>;
}

<span class="comment">// Get the attribute as a float</span>
<span class="keywordtype">float</span> attr4;
<span class="keywordflow">if</span> ( TIXML_SUCCESS != pElem-&gt;<a class="code" href="classTiXmlElement.html#a04d3af11601ef5a5f88295203a843be" title="QueryFloatAttribute examines the attribute - see QueryIntAttribute().">QueryFloatAttribute</a>( <span class="stringliteral">"myAttribute"</span>, &amp;attr4 ) )
{
    <span class="keywordflow">return</span>;
}
</pre></div><p>
TinyXML++ uses templates for automatic type conversion.<p>
Example: <div class="fragment"><pre class="fragment"><span class="keywordflow">try</span>
{
    <span class="comment">// Load a document</span>
    <a class="code" href="classticpp_1_1Document.html" title="Wrapper around TiXmlDocument.">ticpp::Document</a> doc( pFilename );
    doc.LoadFile();

    <span class="comment">// Get an element by chaining calls - no return values to check, no TiXmlHandle</span>
    <a class="code" href="classticpp_1_1Element.html" title="Wrapper around TiXmlElement.">ticpp::Element</a>* pElem = doc.<a class="code" href="classTiXmlNode.html#f4fb652f6bd79ae0d5ce7d0f7d3c0fba" title="Convenience function to get through elements.">FirstChildElement</a>()-&gt;<a class="code" href="classTiXmlNode.html#1b94d2f7fa7ab25a5a8e8d4340c449c9" title="STL std::string form.">NextSibling</a>();

    <span class="comment">// GetAttribute can determine the type of the pointer, and convert automatically</span>

    <span class="comment">// Get the attribute as a string</span>
    std::string attr;
    pElem-&gt;<a class="code" href="classticpp_1_1Element.html#a82b252ee03f4d99a30000e07e3d8d14" title="Gets an attribute of name from an element.">GetAttribute</a>( <span class="stringliteral">"myAttribute"</span>, &amp;attr );

    <span class="comment">// Get the attribute as an int</span>
    <span class="keywordtype">int</span> attr2;
    pElem-&gt;<a class="code" href="classticpp_1_1Element.html#a82b252ee03f4d99a30000e07e3d8d14" title="Gets an attribute of name from an element.">GetAttribute</a>( <span class="stringliteral">"myAttribute"</span>, &amp;attr2 );

    <span class="comment">// Get the attribute as an float</span>
    <span class="keywordtype">float</span> attr3;
    pElem-&gt;<a class="code" href="classticpp_1_1Element.html#a82b252ee03f4d99a30000e07e3d8d14" title="Gets an attribute of name from an element.">GetAttribute</a>( <span class="stringliteral">"myAttribute"</span>, &amp;attr3 );

    <span class="comment">// Get the attribute as an double</span>
    <span class="keywordtype">double</span> attr4;
    pElem-&gt;<a class="code" href="classticpp_1_1Element.html#a82b252ee03f4d99a30000e07e3d8d14" title="Gets an attribute of name from an element.">GetAttribute</a>( <span class="stringliteral">"myAttribute"</span>, &amp;attr4 );

    <span class="comment">// Get the attribute as an bool</span>
    <span class="keywordtype">bool</span> attr5;
    pElem-&gt;<a class="code" href="classticpp_1_1Element.html#a82b252ee03f4d99a30000e07e3d8d14" title="Gets an attribute of name from an element.">GetAttribute</a>( <span class="stringliteral">"myAttribute"</span>, &amp;attr5 );

}
<span class="keywordflow">catch</span>( <a class="code" href="classticpp_1_1Exception.html" title="This is a ticpp exception class.">ticpp::Exception</a>&amp; ex )
{
    <span class="comment">// If any function has an error, execution will enter here.</span>
    <span class="comment">// Report the error</span>
    std::cout &lt;&lt; ex.<a class="code" href="classticpp_1_1Exception.html#eac1f13b96eb4e1f2a3659dc9080edd6" title="Override std::exception::what() to return m_details.">what</a>();
}
</pre></div> <h3>Use STL style iterators to move through nodes and attributes </h3>
<p>
TinyXML has two ways to iterate:<p>
First Method: <div class="fragment"><pre class="fragment">    <span class="keywordflow">for</span>( child = parent-&gt;FirstChild( <span class="keyword">false</span> ); child; child = child-&gt;NextSibling( <span class="keyword">false</span> ) )
</pre></div><p>
Second Method: <div class="fragment"><pre class="fragment">    child = 0;
    <span class="keywordflow">while</span>( child = parent-&gt;IterateChildren( child ) )
</pre></div><p>
Although both methods work quite well, the syntax is not familiar. TinyXML++ introduces iterators: <div class="fragment"><pre class="fragment"><a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Node &gt;</a> child;
<span class="keywordflow">for</span> ( child = child.<a class="code" href="classticpp_1_1Iterator.html#9e0c291db7904e69db16c54632ecaf24" title="For for loop comparisons.">begin</a>( parent ); child != child.<a class="code" href="classticpp_1_1Iterator.html#8ed3f9bf088827f4661613e250d55d58" title="For for loop comparisons.">end</a>(); child++ )
</pre></div><p>
Iterators have the added advantage of filtering by type: <div class="fragment"><pre class="fragment"><span class="comment">// Only iterates through Comment nodes</span>
<a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Comment &gt;</a> child;
<span class="keywordflow">for</span> ( child = child.<a class="code" href="classticpp_1_1Iterator.html#9e0c291db7904e69db16c54632ecaf24" title="For for loop comparisons.">begin</a>( parent ); child != child.<a class="code" href="classticpp_1_1Iterator.html#8ed3f9bf088827f4661613e250d55d58" title="For for loop comparisons.">end</a>(); child++ )
</pre></div><p>
<div class="fragment"><pre class="fragment"><span class="comment">// Only iterates through Element nodes with value "ElementValue"</span>
<a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Element &gt;</a> child( <span class="stringliteral">"ElementValue"</span> );
<span class="keywordflow">for</span> ( child = child.<a class="code" href="classticpp_1_1Iterator.html#9e0c291db7904e69db16c54632ecaf24" title="For for loop comparisons.">begin</a>( parent ); child != child.<a class="code" href="classticpp_1_1Iterator.html#8ed3f9bf088827f4661613e250d55d58" title="For for loop comparisons.">end</a>(); child++ )
</pre></div><p>
Finally, Iterators also work with Attributes <div class="fragment"><pre class="fragment"><a class="code" href="classticpp_1_1Iterator.html" title="Iterator for conveniently stepping through Nodes and Attributes.">ticpp::Iterator&lt; ticpp::Attribute &gt;</a> attribute;
<span class="keywordflow">for</span> ( attribute = attribute.<a class="code" href="classticpp_1_1Iterator.html#9e0c291db7904e69db16c54632ecaf24" title="For for loop comparisons.">begin</a>( element ); attribute != attribute.<a class="code" href="classticpp_1_1Iterator.html#8ed3f9bf088827f4661613e250d55d58" title="For for loop comparisons.">end</a>(); attribute++ )
</pre></div> <hr size="1"><address style="text-align: right;"><small>Generated on Mon Oct 1 10:13:29 2007 for TinyXml by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.3 </small></address>
</body>
</html>
